@implements IDialogContentComponent<Place>


@using TripPlanner.Web.Models
@using TripPlanner.Web.Repositories
@using TripPlanner.Web.Services
@using static TripPlanner.Web.Components.Shared.GpxFileUpload

@inject IPlaceRepository PlaceRepository
@inject IGpxRepository GpxRepository
@inject IHttpClientFactory HttpClientFactory
@inject UserService UserService
@inject GpxService GpxService


<FluentDialogHeader>
    <FluentLabel Typo="Typography.PaneHeader">@(Dialog.Instance.Parameters.Title ?? "Add Place")</FluentLabel>
</FluentDialogHeader>
<FluentDialogBody>
    @if (Content != null)
    {
        <FluentStack Orientation="Orientation.Vertical">
            <FluentTextField @bind-Value="@Content.Name" Label="Name" Required Style="width: 100%;" />
            <FluentTextArea @bind-Value="@Content.Description" Label="Description" Rows="3" Style="width: 100%;" />
            <FluentSelect TOption="string" Value="@_newPlaceCategoryString" Label="Category" Style="width: 100%;" ValueChanged="@OnNewPlaceCategoryChanged">
                @foreach (var category in Enum.GetValues<PlaceCategory>())
                {
                    <FluentOption TOption="string" Value="@category.ToString()">@category.ToString()</FluentOption>
                }
            </FluentSelect>
            <FluentNumberField @bind-Value="@Content.Latitude" Label="Latitude" Step="0.0001" Style="width: 100%;" />
            <FluentNumberField @bind-Value="@Content.Longitude" Label="Longitude" Step="0.0001" Style="width: 100%;" />

            <FluentDatePicker Label="Start" Value="@Content.VisitDate" ValueChanged="@(d => Content.VisitDate = d.HasValue ? d.Value.Date + (Content.VisitDate?.TimeOfDay ?? TimeSpan.Zero) : null)" Style="flex: 1;" />
            <FluentTimePicker Label="Start Time" Value="@Content.VisitDate" ValueChanged="@(t => Content.VisitDate = t.HasValue ? (Content.VisitDate?.Date ?? DateTime.Today) + t.Value.TimeOfDay : null)" Style="flex: 1;" />
            <FluentDatePicker Label="End" Value="@Content.VisitDateEnd" ValueChanged="@(d => Content.VisitDateEnd = d.HasValue ? d.Value.Date + (Content.VisitDateEnd?.TimeOfDay ?? TimeSpan.Zero) : null)" Style="flex: 1;" />
            <FluentTimePicker Label="End Time" Value="@Content.VisitDateEnd" ValueChanged="@(t => Content.VisitDateEnd = t.HasValue ? (Content.VisitDateEnd?.Date ?? DateTime.Today) + t.Value.TimeOfDay : null)" Style="flex: 1;" />

            @if (Content.VisitDate.HasValue && Content.VisitDateEnd.HasValue && Content.VisitDateEnd < Content.VisitDate)
            {
                <FluentLabel Color="Color.Error" Style="font-size: 0.875em;">Visit end date must be on or after the start date.</FluentLabel>
            }


            <FluentDivider Role="DividerRole.Separator" />
            <FluentLabel Style="margin-top: 8px;">Image</FluentLabel>
            @if (_imagePreviewSrc != null)
            {
                <img src="@_imagePreviewSrc" alt="Place image" style="max-width: 100%; max-height: 200px; object-fit: contain; border-radius: 4px;" />
                <FluentButton Appearance="Appearance.Lightweight" OnClick="@RemoveImage">Remove Image</FluentButton>
            }
            <FluentStack Orientation="Orientation.Horizontal" Style="width: 100%; gap: 8px;">
                <FluentTextField @bind-Value="@_imageUrl" Label="Image URL" Style="flex: 1;" Placeholder="https://example.com/image.jpg" />
                <FluentButton Appearance="Appearance.Lightweight" OnClick="@DownloadImageFromUrl" Style="align-self: flex-end;">Download</FluentButton>
            </FluentStack>
            @if (!string.IsNullOrEmpty(_imageError))
            {
                <FluentLabel Color="Color.Error">@_imageError</FluentLabel>
            }
            <FluentLabel Style="font-size: 0.875em; color: var(--neutral-foreground-hint);">Or upload from device:</FluentLabel>
            <InputFile id="@_fileInputId" OnChange="@HandleFileSelected" accept="image/*" style="display: none;" />
            <FluentButton Appearance="Appearance.Outline" OnClick="@TriggerFileInput">Browse</FluentButton>

            <FluentDivider Role="DividerRole.Presentation" />

            <FluentLabel Typo="Typography.Subject">GPX Track (Optional)</FluentLabel>
            @if (!string.IsNullOrEmpty(Content.GpxTrackId))
            {
                var gpxTrack = GpxTracks.FirstOrDefault(g => g.Id == Content.GpxTrackId);
                @if (gpxTrack != null)
                {
                    <FluentCard>
                        <FluentStack Orientation="Orientation.Horizontal">
                            <FluentIcon Icon="Icons.Regular.Size20.Location" Color="Color.Accent" />
                            <FluentStack Orientation="Orientation.Vertical" Style="flex: 1;">
                                <FluentLabel Weight="FontWeight.Bold">@gpxTrack.Name</FluentLabel>
                                <FluentLabel Style="font-size: 0.875em;">
                                    Distance: @gpxTrack.TotalDistance.ToString("F2") km | Points: @gpxTrack.Points.Count
                                </FluentLabel>
                            </FluentStack>
                            <FluentButton Appearance="Appearance.Lightweight" IconStart="@(new Icons.Regular.Size16.Delete())" OnClick="@RemoveGpxTrack">
                            </FluentButton>
                        </FluentStack>
                    </FluentCard>
                }
            }
            else
            {
                <GpxFileUpload OnFileUploaded="@HandleGpxUploaded" />
            }
        </FluentStack>
    }
</FluentDialogBody>
<FluentDialogFooter>
    <FluentButton Appearance="Appearance.Accent" OnClick="@SavePlace">Save</FluentButton>
    <FluentButton Appearance="Appearance.Neutral" OnClick="@CancelAsync">Cancel</FluentButton>
</FluentDialogFooter>


@code {
    [Parameter]
    public Place Content { get; set; } = default!;
    private string _newPlaceCategoryString = string.Empty;

    [CascadingParameter]
    public FluentDialog Dialog { get; set; } = default!;
    
    private List<GpxTrack> GpxTracks { get; set; } = new();

    private string _imageUrl = string.Empty;
    private string? _imagePreviewSrc;
    private string? _imageError;
    private string _fileInputId = $"img-upload-{Guid.NewGuid():N}";
    private const long MaxImageSizeBytes = 5 * 1024 * 1024;

    private ApplicationUser? CurrentUser { get; set; }

    [Inject] private IJSRuntime JS { get; set; } = default!;



    protected override async Task OnInitializedAsync()
    {
        CurrentUser = await UserService.GetCurrentUserAsync();
        await LoadGpxTracks();
    }

    protected override void OnParametersSet()
    {
        if (Content?.ImageData != null && Content.ImageContentType != null)
        {
            _imagePreviewSrc = $"data:{Content.ImageContentType};base64,{Convert.ToBase64String(Content.ImageData)}";
        }
    }

    private async Task LoadGpxTracks()
    {
        GpxTracks = await GpxRepository.GetAllAsync();
    }

    private void OnNewPlaceCategoryChanged(string value)
    {
        _newPlaceCategoryString = value;
        if (Content != null && Enum.TryParse<PlaceCategory>(value, out var category))
        {
            Content.Category = category;
        }
    }

    private async Task DownloadImageFromUrl()
    {
        _imageError = null;
        if (string.IsNullOrWhiteSpace(_imageUrl))
            return;

        if (!Uri.TryCreate(_imageUrl, UriKind.Absolute, out var uri) ||
            (uri.Scheme != Uri.UriSchemeHttp && uri.Scheme != Uri.UriSchemeHttps))
        {
            _imageError = "Please enter a valid http or https URL.";
            return;
        }

        try
        {
            using var client = HttpClientFactory.CreateClient();
            client.Timeout = TimeSpan.FromSeconds(15);
            var response = await client.GetAsync(uri);
            response.EnsureSuccessStatusCode();

            var contentType = response.Content.Headers.ContentType?.MediaType ?? "image/jpeg";
            if (!contentType.StartsWith("image/", StringComparison.OrdinalIgnoreCase))
            {
                _imageError = "The URL does not point to an image.";
                return;
            }

            var data = await response.Content.ReadAsByteArrayAsync();
            if (data.Length > MaxImageSizeBytes)
            {
                _imageError = "Image exceeds the 5 MB size limit.";
                return;
            }

            Content.ImageData = data;
            Content.ImageContentType = contentType;
            _imagePreviewSrc = $"data:{contentType};base64,{Convert.ToBase64String(data)}";
        }
        catch (Exception ex)
        {
            _imageError = $"Could not download image: {ex.Message}";
        }
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        _imageError = null;
        var file = e.File;

        if (!file.ContentType.StartsWith("image/", StringComparison.OrdinalIgnoreCase))
        {
            _imageError = "Please select an image file.";
            return;
        }

        if (file.Size > MaxImageSizeBytes)
        {
            _imageError = "Image exceeds the 5 MB size limit.";
            return;
        }

        using var stream = file.OpenReadStream(maxAllowedSize: MaxImageSizeBytes);
        using var ms = new MemoryStream();
        await stream.CopyToAsync(ms);

        Content.ImageData = ms.ToArray();
        Content.ImageContentType = file.ContentType;
        _imagePreviewSrc = $"data:{file.ContentType};base64,{Convert.ToBase64String(Content.ImageData)}";
    }

    private async Task TriggerFileInput()
    {
        await JS.InvokeVoidAsync("clickElementById", _fileInputId);
    }

    private void RemoveImage()
    {
        Content.ImageData = null;
        Content.ImageContentType = null;
        _imagePreviewSrc = null;
        _imageUrl = string.Empty;
    }

    private async Task SavePlace()
    {
        if (CurrentUser is null)
            return;

        if (Content == null || string.IsNullOrWhiteSpace(Content.Name))
            return;

        var dbPlace = await PlaceRepository.GetByIdAsync(Content.Id, CurrentUser.Id);

        if (dbPlace is null)
        {
            await PlaceRepository.AddAsync(Content);
        }
        else
        {
            await PlaceRepository.UpdateAsync(Content);
        }
        await Dialog.CloseAsync(Content);
    }


    private async Task HandleGpxUploaded(GpxUploadResult result)
    {
        if (result.Success && Content != null)
        {
            try
            {
                // Parse the GPX file
                var gpxTrack = GpxService.ParseGpxContent(result.Content, result.FileName);
                gpxTrack.CreatedAt = DateTime.UtcNow;

                // Save the GPX track
                await GpxRepository.AddAsync(gpxTrack);

                // Link it to the place
                Content.GpxTrackId = gpxTrack.Id;

                // Reload GPX tracks
                await LoadGpxTracks();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing GPX file: {ex.Message}");
            }
        }
    }

    private void RemoveGpxTrack()
    {
        if (Content != null)
        {
            Content.GpxTrackId = null;
        }
    }



    
    private async Task CancelAsync()
    {
        await Dialog.CancelAsync();
    }
}